# -*- coding: utf-8 -*-
"""
Created on Tue Apr 24 19:46:34 2018

@author: Rudy
"""

import measure
import markov
import copy
import pickle
import pretty_midi
import random
from markov_learn_and_create import *

FAST = 0
MED = 1
SLOW = 2
VERY_SLOW = 3

def random_beats(n, tempo):
#    print("random_beats " + str(n))
    random.seed()
    beat_choices = [1., 1./2, 1./4, 1./8]
    fast_prob = [0.25, 0.5, 0.75, 0.25]
    med_prob = [0.25,0.75,0.5,0]
    slow_prob = [1.5,1.0,0.25,0]
    very_slow_prob = [2.0,1.0,0,0]
    probs = [fast_prob, med_prob, slow_prob, very_slow_prob]
    prob = probs[tempo]
    population = []
    weights = []
    for i in range(4):
        if beat_choices[i]-n <= 0.0001:
            population.append(beat_choices[i])
            weights.append(prob[i])
    beat = random.choices(population, weights=weights)

    if n-beat[0] <= 0: return beat
    return beat+random_beats(n-beat[0], tempo)

def predefined_unit_generator(markov, beats, time, tempo):
    if markov == None: markov = load_markov("default_markov")   #TODO: still need to develop a default markov chain
    if type(markov) == str: markov = load_markov(markov)
    #otherwise markov is a markov Class
    created_measure = markov.create_notes(length=30)
    beats = random_beats(beats, tempo)
    durations = [int(beat*measure.Unit.lpq) for beat in beats]
#    print("total beats = %d" % sum(beats))
#    beats = [beat*rate for beat in beats]
#    print(beats)
    notes = [note.pitch for note in created_measure[:len(beats)]]
    generated_unit = measure.Unit(notes, durations=durations, time=time)
    return generated_unit

    
def save_unit(measure, filename):
    fileObject = open(filename, 'wb')
    pickle.dump(measure, fileObject)

def load_unit(filename):
    fileObject = open(filename, 'rb')
    measure = pickle.load(fileObject)
    return measure

def variation_piano(unit):
    new_unit = copy.deepcopy(unit)
    new_notes = new_unit.get_notes()
    times = random.choice([1,2])
    for i in range(times):
        idx = random.choice(range(len(new_notes) ))
        while(new_notes[idx] == 0): idx = random.choice(range(len(new_notes) ))
        pitch = new_notes[idx]
        avg = sum(new_notes)
        co = random.choice([1,-1])
        amp = random.choice(range(4,8))
        for i in range(len(new_notes)):
            if new_notes[i] == pitch: new_notes[i] += amp*co
        new_unit.set_notes(new_notes)
#    print(unit)
#    print(new_unit)
    return new_unit

def composition_rule_piano(unit):
    unit.wipe_end()
    last_variation = copy.deepcopy(unit)
    for i in range(3):
        last_variation = (variation_piano(last_variation))
        unit.extend_unit(last_variation)
    return unit
    
    
# This composition rule takes a piece of input which is exactly a measure.
# What it does is: randomly choose 1/4 of the notes and replace them by other notes generated by Markov
    pass 
    
def manual_generate_drum(starts, durs, velos, notes=None,time=3):
    if notes ==None:
        notes = [37 for i in range(len(starts))]
    drum_unit = measure.Unit(notes, starts, durs, velocities=velos, time=time)
    return drum_unit

if __name__ == "__main__":
    
#    markov = load_markov("calm_piano_main.markov")
    testmidi = pretty_midi.PrettyMIDI()
    testmidi.instruments.append(pretty_midi.Instrument(16, is_drum=True))
#    generated_unit = predefined_unit_generator(markov, 4, 3, VERY_SLOW)
#    generated_unit = composition_rule_piano(generated_unit)
##    generated_unit = load_unit("measure01.mes")
#    testmidi.instruments[0].notes = generated_unit.to_midi_notes() 
#    testmidi.write("generated_unit_veryslow.mid")
    notes = [37,37,37,40,39,37]*2
    starts = [0, 0.5, 1.5, 2, 3, 3.5, 4, 4.5, 5.5, 6, 7, 7.5]
    durs =   [0.5, 1, 0.5, 1,0.5,0.5]*2
    velos = [101,101,101,101,101,0]*2
    starts = [start*measure.Unit.lpq for start in starts]
    durs = [dur*measure.Unit.lpq for dur in durs]
    generated_drums = manual_generate_drum(starts, durs, velos, notes=notes)
#    generated_drums = load_unit("drum_fast3.mes")
    testmidi.instruments[0].notes = generated_drums.to_midi_notes() 
    testmidi.write("generated_drums_fast4.mid")
    