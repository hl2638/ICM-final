# -*- coding: utf-8 -*-
"""
Created on Tue Apr 24 19:46:34 2018

@author: Rudy
"""

import measure
import markov
import copy
import pickle
import unit_lib
import pretty_midi
import random
from markov_learn_and_create import *

FAST = 0
MED = 1
SLOW = 2
VERY_SLOW = 3

def random_beats(n, tempo=1):
#    print("random_beats " + str(n))
    random.seed()
    beat_choices = [1., 1./2, 1./4, 1./8]
    fast_prob = [0.1, 0.5, 0.75, 0.25]
    med_prob = [0.25,0.75,0.5,0]
    slow_prob = [1.5,1.0,0.25,0]
    very_slow_prob = [2.0,1.0,0,0]
    probs = [fast_prob, med_prob, slow_prob, very_slow_prob]
    prob = probs[tempo]
    population = []
    weights = []
    for i in range(4):
        if beat_choices[i]-n <= 0.0001:
            population.append(beat_choices[i])
            weights.append(prob[i])
    beat = random.choices(population, weights=weights)

    if n-beat[0] <= 0: return beat
    return beat+random_beats(n-beat[0], tempo)

def predefined_unit_generator(markov, beats, time, tempo=1):
    if markov == None: markov = load_markov("default_markov")   #TODO: still need to develop a default markov chain
    if type(markov) == str: markov = load_markov(markov)
    #otherwise markov is a markov Class
    created_measure = markov.create_notes(length=30)
    beats = random_beats(beats, tempo)
    durations = [int(beat*measure.Unit.lpq) for beat in beats]
#    print("total beats = %d" % sum(beats))
#    beats = [beat*rate for beat in beats]
#    print(beats)
    notes = [note.pitch for note in created_measure[:len(beats)]]
    generated_unit = measure.Unit(notes, durations=durations, time=time)
    return generated_unit

    
def save_unit(measure, filename):
    fileObject = open(filename, 'wb')
    pickle.dump(measure, fileObject)

def load_unit(filename):
    fileObject = open(filename, 'rb')
    measure = pickle.load(fileObject)
    return measure

def variation_piano(unit, markov):
    new_unit = copy.deepcopy(unit)
    new_notes = new_unit.get_notes()
#    times = random.choice([1,2])
    times = random.choice([2,3])
    for i in range(times):
        idx = random.choice(range(len(new_notes) ))
        while(new_notes[idx] == 0): idx = random.choice(range(len(new_notes) ))
        pitch = new_notes[idx]
        avg = sum(new_notes)
        co = random.choice([1,-1])
        amp = random.choice(range(4,8))
        for i in range(1, len(new_notes)):
            if new_notes[i] == pitch: new_notes[i] = markov.next_note(new_notes[i-1])
        new_unit.set_notes(new_notes)
#    print(unit)
#    print(new_unit)
    return new_unit

def composition_rule_piano(unit, markov):
    unit.wipe_end()
    last_variation = copy.deepcopy(unit)
    for i in range(3):
        last_variation = (variation_piano(last_variation, markov))
        unit.extend_unit(last_variation)
    return unit
    
    
# This composition rule takes a piece of input which is exactly a measure.
# What it does is: randomly choose 1/4 of the notes and replace them by other notes generated by Markov
    pass 
    
def manual_generate_drum(starts, durs, velos, notes=None,time=3):
    if notes ==None:
        notes = [37 for i in range(len(starts))]
    drum_unit = measure.Unit(notes, starts, durs, velocities=velos, time=time)
    return drum_unit

if __name__ == "__main__":
    
    myMarkov = load_markov("hype_piano_accompany.markov")
    testmidi = pretty_midi.PrettyMIDI()
    testmidi.instruments.append(pretty_midi.Instrument(0))
    testmidi.instruments.append(pretty_midi.Instrument(16, is_drum=True))
    generated_unit = predefined_unit_generator(myMarkov, 4, 3, FAST)
#    generated_unit = composition_rule_piano(generated_unit, myMarkov)
##    generated_unit = load_unit("measure01.mes")
    testmidi.instruments[0].notes = generated_unit.to_midi_notes() 
#    drums_lib = unit_lib.load_lib("drums_lib.lib")
#    generated_unit = drums_lib.get_unit('FAST')
#    testmidi.instruments[1].notes = generated_unit.to_midi_notes() 
    testmidi.write("generated_unit_fast.mid")
    
#    notes = [37,37,37,37,37]
#    starts = [0, 0.5, 1, 2, 3]
#    durs =   [0.5, 0.5, 1, 1, 1]
#    velos = [101, 101, 0, 101, 101]
#    starts = [start*measure.Unit.lpq for start in starts]
#    durs = [dur*measure.Unit.lpq for dur in durs]
#    generated_drums = manual_generate_drum(starts, durs, velos, notes=notes)
##    generated_drums = load_unit("drum_slow3.mes")
##    testmidi.instruments[0].notes = generated_drums.to_midi_notes() 
##    testmidi.write("generated_drums_fast2.mid")
#    
#    drums_lib = unit_lib.load_lib("drums_lib.lib")
#    unit = drums_lib.get_unit('SLOW')
#    testmidi.instruments[0].notes = unit.to_midi_notes()
#    testmidi.write("test_lib_slow.mid")
#    