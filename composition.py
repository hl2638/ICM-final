# -*- coding: utf-8 -*-
"""
Created on Tue Apr 24 19:46:34 2018

@author: Rudy
"""

import measure
import markov
import pickle
import pretty_midi
import random
from markov_learn_and_create import *

def random_beats(n):
#    print("random_beats " + str(n))
    random.seed()
    beat_choices = [1., 1./2, 1./4, 1./8]
    prob = [0.25, 0.5, 0.5, 0.25]
    population = []
    weights = []
    for i in range(4):
        if beat_choices[i]-n <= 0.0001:
            population.append(beat_choices[i])
            weights.append(prob[i])
    beat = random.choices(population, weights=weights)

    if n-beat[0] <= 0: return beat
    return beat+random_beats(n-beat[0])

def predefined_unit_generator(markov, beats, time):
    if markov == None: markov = load_markov("default_markov")   #TODO: still need to develop a default markov chain
    if type(markov) == str: markov = load_markov(markov)
    #otherwise markov is a markov Class
    created_measure = markov.create_notes(length=30)
    beats = random_beats(beats)
    durations = [int(beat*measure.Unit.lpq) for beat in beats]
#    print("total beats = %d" % sum(beats))
#    beats = [beat*rate for beat in beats]
#    print(beats)
    notes = [note.pitch for note in created_measure[:len(beats)]]
    generated_unit = measure.Unit(notes, durations=durations, time=time)
    return generated_unit

    
def save_unit(measure, filename):
    fileObject = open(filename, 'wb')
    pickle.dump(measure, fileObject)

def load_unit(filename):
    fileObject = open(filename, 'rb')
    measure = pickle.load(fileObject)
    return measure


def composition_rule1(measure):

# This composition rule takes a piece of input which is exactly a measure.
# What it does is: randomly choose 1/4 of the notes and replace them by other notes generated by Markov
    pass
    


if __name__ == "__main__":
    
    markov = load_markov("calm_piano_main.markov")
    testmidi = pretty_midi.PrettyMIDI ()
    testmidi.instruments.append(pretty_midi.Instrument(0))
#    print(type(predefined_measure_generator(markov)))
    generated_unit = predefined_unit_generator(markov, 4, 2).to_midi_notes()
#    generated_measure = load_measure("generated_measure02.mes")
    testmidi.instruments[0].notes = generated_unit
    testmidi.write("generated_unit.mid")